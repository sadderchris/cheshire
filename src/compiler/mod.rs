use core::str::FromStr;

use gc_arena::{static_collect, Collect, CollectionContext, Gc, GcCell, MutationContext};
use indexmap::set::{IndexSet, Iter};
use pest::error::{Error, ErrorVariant};
use pest::iterators::Pair;
use pest::{Position, Span};

use crate::chunk::Chunk;
use crate::memory::{Symbol, Token};
use crate::object::{ObjPair, ObjString, ObjVector};
use crate::scanner::Rule;
use crate::value::Datum;
use crate::vm::VirtualMachine;

pub mod bootstrap;

pub type Result<T> = std::result::Result<T, Error<Rule>>;

/// An Upvalue generated by the compiler
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Upvalue {
    index: u8,
    is_local: bool,
}

/// Struct representing Upvalues generated by the compiler
#[derive(Debug, Default, Clone)]
pub struct Upvalues(IndexSet<Upvalue>);

impl Upvalues {
    pub fn contains(&self, upvalue: &Upvalue) -> bool {
        self.0.contains(upvalue)
    }

    pub fn insert(&mut self, upvalue: Upvalue) -> bool {
        self.0.insert(upvalue)
    }

    pub fn get_index_of(&self, upvalue: &Upvalue) -> Option<usize> {
        self.0.get_index_of(upvalue)
    }

    pub fn len(&self) -> usize {
        self.0.len()
    }

    pub fn is_empty(&self) -> bool {
        self.0.is_empty()
    }

    pub fn iter(&self) -> Iter<'_, Upvalue> {
        self.0.iter()
    }

    pub fn add_upvalue(&mut self, upvalue: Upvalue) -> usize {
        let upvalue_count = self.len();

        if let Some(index) = self.get_index_of(&upvalue) {
            return index;
        }

        if upvalue_count == u8::MAX as usize + 1 {
            panic!("Too many closure variables in function");
        }

        self.insert(upvalue);
        upvalue_count
    }
}

static_collect!(Upvalues);

#[derive(Debug, Default, Clone)]
struct Locals<'gc>(IndexSet<Symbol<'gc>>);

impl Locals<'_> {
    pub fn len(&self) -> usize {
        self.0.len()
    }
}

impl<'gc> Locals<'gc> {
    pub fn contains(&self, symbol: &Symbol<'gc>) -> bool {
        self.0.contains(symbol)
    }

    pub fn insert(&mut self, symbol: Symbol<'gc>) -> bool {
        self.0.insert(symbol)
    }

    pub fn get_index_of(&self, symbol: &Symbol<'gc>) -> Option<usize> {
        self.0.get_index_of(symbol)
    }
}

unsafe impl<'gc> Collect for Locals<'gc> {
    fn trace(&self, cc: CollectionContext<'_>) {
        for e in self.0.iter() {
            e.trace(cc);
        }
    }
}

#[derive(Debug, Default, Collect)]
#[collect(no_drop)]
pub struct CompilerContext<'gc> {
    parent: Option<GcCell<'gc, CompilerContext<'gc>>>,
    upvalues: Upvalues,
    locals: Locals<'gc>,
    local0: Option<Symbol<'gc>>,
    chunk: Chunk<'gc>,
    scope_depth: usize,
}

impl<'gc> CompilerContext<'gc> {
    pub fn new() -> Self {
        Self {
            parent: None,
            upvalues: Upvalues::default(),
            locals: Locals::default(),
            local0: None,
            chunk: Chunk::default(),
            scope_depth: 0,
        }
    }

    pub fn with_parent(parent: GcCell<'gc, CompilerContext<'gc>>) -> Self {
        Self {
            parent: Some(parent),
            upvalues: Upvalues::default(),
            locals: Locals::default(),
            local0: None,
            chunk: Chunk::default(),
            scope_depth: parent.read().scope_depth + 1,
        }
    }
}

fn error(err: String, span: Span<'_>) -> Error<Rule> {
    Error::new_from_span(ErrorVariant::CustomError { message: err }, span)
}

fn error_at(err: String, pos: Position<'_>) -> Error<Rule> {
    Error::new_from_pos(ErrorVariant::CustomError { message: err }, pos)
}

pub fn read_with_lineinfo<'gc>(
    current: Pair<'_, Rule>,
    vm: &VirtualMachine<'gc>,
    mc: MutationContext<'gc, '_>,
) -> Result<Datum<'gc>> {
    match current.as_rule() {
        Rule::abbreviation => Ok(Datum::from(read_abbreviation(current, vm, mc)?)),
        Rule::boolean => Ok(Datum::from(read_boolean(current)?)),
        Rule::character => Ok(Datum::from(read_character(current)?)),
        Rule::number => Ok(Datum::from(read_number(current)?)),
        Rule::proper_list => read_proper_list(current, vm, mc),
        Rule::improper_list => read_improper_list(current, vm, mc),
        Rule::string => Ok(Datum::from(read_string(current, mc)?)),
        Rule::symbol => Ok(Datum::from(read_symbol(current, vm, mc)?)),
        Rule::vector => Ok(Datum::from(read_vector(current, vm, mc)?)),
        Rule::EOI => Ok(Datum::Eof),
        _ => Err(error(
            format!("Unknown literal '{}'", current.as_str()),
            current.as_span().clone(),
        )),
    }
}

pub fn read<'gc>(
    current: Pair<'_, Rule>,
    vm: &VirtualMachine<'gc>,
    mc: MutationContext<'gc, '_>,
) -> Result<Datum<'gc>> {
    match current.as_rule() {
        Rule::abbreviation => Ok(Datum::from(read_abbreviation(current, vm, mc)?)),
        Rule::boolean => Ok(Datum::from(read_boolean(current)?)),
        Rule::character => Ok(Datum::from(read_character(current)?)),
        Rule::number => Ok(Datum::from(read_number(current)?)),
        Rule::proper_list => read_proper_list(current, vm, mc),
        Rule::improper_list => read_improper_list(current, vm, mc),
        Rule::string => Ok(Datum::from(read_string(current, mc)?)),
        Rule::symbol => Ok(Datum::from(read_symbol(current, vm, mc)?)),
        Rule::vector => Ok(Datum::from(read_vector(current, vm, mc)?)),
        Rule::EOI => Ok(Datum::Eof),
        _ => Err(error(
            format!("Unknown literal '{}'", current.as_str()),
            current.as_span().clone(),
        )),
    }
}

fn read_abbreviation<'gc>(
    current: Pair<'_, Rule>,
    vm: &VirtualMachine<'gc>,
    mc: MutationContext<'gc, '_>,
) -> Result<Gc<'gc, ObjPair<Datum<'gc>>>> {
    let span = current.as_span().clone();
    let current_str = current.as_str().to_string();
    let mut inner = current.into_inner();
    let prefix = inner.next().ok_or_else(|| {
        error(
            "Couldn't parse the abbreviation prefix".to_string(),
            span.clone(),
        )
    })?;
    let quoted = inner
        .next()
        .ok_or_else(|| error("Couldn't parse the quoted datum".to_string(), span.clone()))?;

    match prefix.as_str() {
        "'" => {
            let symbol = vm.intern_symbol(Token::new(mc, "quote".into()), mc);
            Ok(Gc::allocate(
                mc,
                ObjPair::new(
                    Datum::Symbol(symbol),
                    Datum::Pair(Gc::allocate(
                        mc,
                        ObjPair::new(read(quoted, vm, mc)?, Datum::Null),
                    )),
                ),
            ))
        }
        _ => Err(error(
            format!("Tried to parse '{}' as an abbreviation", current_str),
            span.clone(),
        )),
    }
}

fn read_boolean(current: Pair<'_, Rule>) -> Result<bool> {
    match current.as_str() {
        "#t" | "#T" => Ok(true),
        "#f" | "#F" => Ok(false),
        _ => Err(error(
            format!("Tried to parse '{}' as a boolean", current.as_str()),
            current.as_span().clone(),
        )),
    }
}

fn read_character(current: Pair<'_, Rule>) -> Result<char> {
    let position = current.as_span().start_pos();

    let character = match current.into_inner().next().unwrap().as_str() {
        c if c.eq_ignore_ascii_case("space") => ' ',
        c if c.eq_ignore_ascii_case("newline") => '\n',
        c => char::from_str(c)
            .map_err(|_| error_at(format!("Couldn't parse character {}", c), position))?,
    };

    Ok(character)
}

fn read_number(current: Pair<'_, Rule>) -> Result<f64> {
    let number = current.as_str().parse::<f64>().map_err(|_| {
        error(
            format!("'{}' is not a number", current.as_str()),
            current.as_span().clone(),
        )
    })?;

    Ok(number)
}

fn read_proper_list<'gc>(
    current: Pair<'_, Rule>,
    vm: &VirtualMachine<'gc>,
    mc: MutationContext<'gc, '_>,
) -> Result<Datum<'gc>> {
    current
        .into_inner()
        .map(|value| read(value, vm, mc))
        .try_rfold(Datum::Null, |acc, x| {
            Ok(Datum::Pair(Gc::allocate(mc, ObjPair::new(x?, acc))))
        })
}

fn read_improper_list<'gc>(
    current: Pair<'_, Rule>,
    vm: &VirtualMachine<'gc>,
    mc: MutationContext<'gc, '_>,
) -> Result<Datum<'gc>> {
    let span = current.as_span().clone();
    let mut inner = current.into_inner().rev().map(|value| read(value, vm, mc));

    let first = inner.next().ok_or_else(|| {
        error(
            "Expected at least one element in the improper list".to_string(),
            span,
        )
    })?;

    inner.try_fold(first?, |acc, x| {
        Ok(Datum::Pair(Gc::allocate(mc, ObjPair::new(x?, acc))))
    })
}

fn read_string<'gc>(
    current: Pair<'_, Rule>,
    mc: MutationContext<'gc, '_>,
) -> Result<Gc<'gc, ObjString>> {
    let obj_string = ObjString::from(current.into_inner().as_str());
    let value = Gc::allocate(mc, obj_string);
    Ok(value)
}

fn read_symbol<'gc>(
    current: Pair<'_, Rule>,
    vm: &VirtualMachine<'gc>,
    mc: MutationContext<'gc, '_>,
) -> Result<Symbol<'gc>> {
    let symbol = vm.intern_symbol(Token::new(mc, current.as_str().into()), mc);
    Ok(symbol)
}

fn read_vector<'gc>(
    current: Pair<'_, Rule>,
    vm: &VirtualMachine<'gc>,
    mc: MutationContext<'gc, '_>,
) -> Result<Gc<'gc, ObjVector<Datum<'gc>>>> {
    let vector: Result<Vec<_>> = current
        .into_inner()
        .map(|value| read(value, vm, mc))
        .collect();
    Ok(Gc::allocate(mc, ObjVector::new(vector?.into_boxed_slice())))
}
